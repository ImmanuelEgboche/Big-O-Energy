🔥 Tier 1 — The Ubers

These always show up:

Arrays / Strings → sliding window, two pointers, prefix sums, hashing tricks.

HashMaps / HashSets → counting, deduplication, quick lookups.

Stacks & Queues → monotonic stacks for “next greater element,” BFS, parentheses validation.

⚡ Tier 2 — The Regulars

Heaps / Priority Queues → top-k problems, merging sorted lists, median-in-stream.

Binary Search (on arrays or answer space) → super common pattern, not just on sorted arrays.

Graphs (DFS/BFS, Dijkstra, Union-Find) → connectivity, shortest path, islands problems.

🌲 Tier 3 — Conceptual / Sometimes

Binary Search Trees → LCA, validate BST, kth smallest, etc. Rarely “implement one.”

Linked Lists → cycle detection, reverse, merge.

Tries → prefix problems, autocomplete.

Intervals → merge intervals, insert interval, meeting rooms.

🧠 Tier 4 — Big Brain But Rare

Segment Trees / Fenwick Trees (BITs) → range sums, range updates (more common at quant/trading firms).

Balanced BSTs (AVL, Red-Black, Treaps) → almost never asked to implement, but might be useful to know of.

Disjoint Sets (Union-Find) → common for connectivity/graph clustering problems, but not as universal as heaps.